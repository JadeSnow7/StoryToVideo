# 架构设计文档（飞书交付稿）

## 1. 总体架构
- **三层模型**：PC 客户端（Qt/QML） ←→ 云端服务（Django/DRF + 任务队列） ←→ 本地模型节点（FastAPI，经 FRP 暴露）。
- **通信模式**：REST + WebSocket，长任务由队列驱动；WS 推送状态，HTTP 轮询兜底。
- **核心目标**：解耦生成算力与业务网关，保证 UI 流畅、任务可追踪、资源可复用。

## 2. 关键模块
### 客户端（Qt/QML + C++)
- **UI/状态管理**：ViewModel 单向数据流，统一状态枚举 PENDING/RUNNING/SUCCESS/FAILED。
- **网络层**：QNetworkAccessManager + WebSocket；失败自动重试 + 指数退避；任务轮询兜底。
- **媒体能力**：FFmpeg + OpenGL 播放/合成，支持截图、进度控制与 MP4 导出。
- **存储**：SQLite + 文件缓存保存项目、图片、视频；离线可读历史内容。

### 服务端（Django/DRF 或 Gin）
- **API 网关**：鉴权、限流、日志；统一错误码；反向代理静态资源。
- **任务队列**：Celery/RQ，支持超时、重试、幂等，写入 Task 表；完成后触发 Webhook/WS。
- **数据存储**：PostgreSQL/MySQL；对象存储 OSS/TOS 保存图片/音频/视频；可选 CDN 加速。

### 模型节点（FastAPI）
- **LLM（Qwen2.5-0.5B/Ollama）**：分镜 JSON 与旁白生成。
- **T2I（SD Turbo）**：根据 Prompt 输出关键帧图片。
- **I2V（SVD Img2Vid，可选）**：将图片转短视频片段。
- **TTS（CosyVoice-mini）**：生成旁白音频。
- **FRP**：frpc 将本地端口暴露给云端任务 Worker，保证内网 GPU 可用。

## 3. 数据与 API 设计
- **数据模型**：
  - Project(id, title, style, created_at)
  - Shot(id, project_id, order, prompt, narration, image_url, video_url, status)
  - Task(id, type, payload, status, result_data, err_msg)
- **网关设计**：
  - **入口**：Nginx/Traefik → API 网关（OpenResty/Lua）→ 应用服务。HTTPS 强制、HSTS、限流（滑动窗口）、WAF 规则拦截。
  - **鉴权**：登录获取 JWT/Token，所有业务接口需在 Header `Authorization: Bearer <token>`；网关验证签名与过期时间；支持临时 STS Token 访问 OSS 资源。
  - **路由与重试**：API 网关转发到 DRF/Gin，5xx 触发幂等接口一次性重试；静态与媒体资源走 OSS/CDN；WebSocket 升级透传。
  - **观测与日志**：接入 TraceID，统一 Access Log（含 upstream）和 Error Log；暴露 Prometheus 指标（qps/rt/4xx/5xx）。
- **API 核心路由与报文**：
  - POST `/api/projects/create`
    - Request: `{ "title": "My Story", "style": "movie", "story": "...500 字以内" }`
    - Response: `{ "project_id": "p_123", "shots": [{"id":"s1","order":1,"prompt":"...","narration":"...","status":"PENDING"}] , "task_id": "t_llm_1" }`
  - GET `/api/projects/{id}/storyboard`
    - Response: `{ "project_id": "p_123", "shots": [...], "updated_at": "2024-11-18T10:00:00Z" }`
  - POST `/api/shots/{id}/update_prompt`
    - Request: `{ "prompt": "sunset city", "narration": "voice text" }`
    - Response: `{ "id": "s1", "prompt": "...", "narration": "..." }`
  - POST `/api/shots/{id}/generate_image`
    - Request: `{ "model": "sd_turbo", "seed": 123, "cfg_scale": 5.5, "steps": 6 }`
    - Response: `{ "task_id": "t_img_1", "status": "QUEUED" }`
  - POST `/api/shots/{id}/generate_video`（可选）
    - Request: `{ "model": "svd_img2vid", "fps": 24, "duration": 3 }`
    - Response: `{ "task_id": "t_vid_1", "status": "QUEUED" }`
  - GET `/api/tasks/{task_id}/status`
    - Response: `{ "task_id": "t_img_1", "status": "SUCCESS", "result": {"image_url":"https://.../s1.png"}, "err_msg": null }`
  - POST `/api/webhook/task_complete`
    - Request: `{ "task_id": "t_img_1", "status": "SUCCESS", "result": {...}, "signature": "hmac" }`
    - 校验 HMAC（共享密钥），写回 Task 表并推送 WS；失败返回 4xx，供模型节点重试。
  - **统一错误码**：`code` 字段（0 成功，4xx 客户端错误、5xx 服务错误、9xx 业务错误如算力不足），`message` 描述，`request_id` 便于追踪。

## 4. 关键流程示意
1) **分镜生成**：客户端提交故事 → 网关写入 Project+Shot → 任务入队调用 LLM → 写回分镜 JSON → WS 推送前端刷新。
2) **图片生成**：客户端调用 generate_image → 任务入队 → Worker 通过 FRP 调用 SD Turbo → 上传 OSS → 回调任务 SUCCESS → WS/轮询更新 URL。
3) **视频合成与导出**：客户端请求合成 → 任务队列调 FFmpeg 拼接（可叠加旁白）→ 成功后提供下载/本地保存路径。

## 5. 视频合成与媒体流水线设计
- **合成输入**：有序 Shot 列表（含 image_url/video_url、旁白音频、过渡配置），全局参数（分辨率、帧率、BGM 选择、字幕开关）。
- **流水线**：
  1. **下载阶段**：从 OSS 并发拉取图片/视频/音频到临时目录，校验哈希；失败重试 3 次。
  2. **转码阶段**：统一分辨率/帧率，图片转视频片段（Ken Burns 或静态帧），旁白转 WAV；BGM 按 LoudNorm 归一。
  3. **拼接阶段**：FFmpeg concat 脚本生成主视频流；插入可选淡入/淡出、交叉淡化；字幕由 SRT/ASS 叠加。
  4. **混音阶段**：旁白与 BGM 混音，控制 Ducking（旁白时降低 BGM 6dB）；输出 AAC。
  5. **导出阶段**：H.264 + AAC MP4，CBR/2-pass 可选；生成本地文件并上传 OSS（若选择云端导出）。
- **并发与资源**：合成任务 CPU 密集，worker 可按 CPU 核数并行；长任务设置超时（如 5 分钟）与断点续传（分段中间文件）。
- **质量控制**：支持预览模式（低码率、短时长）与正式导出模式；合成日志记录关键参数，失败输出 stderr 供诊断。

## 6. 部署与运维
- **环境**：云端 Ubuntu 22.04，Python 3.10+；Nginx+Gunicorn 部署后端；PostgreSQL + Redis；本地 GPU 节点通过 FRP 联通。
- **可观察性**：Prometheus + Grafana 指标，Sentry 捕获异常，结构化日志输出（TraceID 贯穿任务）。
- **安全**：HTTPS、JWT/Token 鉴权；OSS 资源带签名；任务接口限流；敏感配置使用环境变量/密钥管理。

## 7. 风险与缓解
- **生成耗时波动**：通过任务队列超时+重试、WS+轮询双通道反馈。
- **模型不可用**：备用 Mock 服务/降级提示；支持切换到云端备份算力。
- **大文件传输**：采用分段上传至 OSS，返回 CDN URL，客户端异步加载。
