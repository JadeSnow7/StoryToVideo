# 架构设计文档（飞书交付稿）

## 1. 总体架构
- **三层模型**：PC 客户端（Qt/QML） ←→ 云端服务（Django/DRF + 任务队列） ←→ 本地模型节点（FastAPI，经 FRP 暴露）。
- **通信模式**：REST + WebSocket，长任务由队列驱动；WS 推送状态，HTTP 轮询兜底。
- **核心目标**：解耦生成算力与业务网关，保证 UI 流畅、任务可追踪、资源可复用。

## 2. 关键模块
### 客户端（Qt/QML + C++)
- **UI/状态管理**：ViewModel 单向数据流，统一状态枚举 PENDING/RUNNING/SUCCESS/FAILED。
- **网络层**：QNetworkAccessManager + WebSocket；失败自动重试 + 指数退避；任务轮询兜底。
- **媒体能力**：FFmpeg + OpenGL 播放/合成，支持截图、进度控制与 MP4 导出。
- **存储**：SQLite + 文件缓存保存项目、图片、视频；离线可读历史内容。

### 服务端（Django/DRF 或 Gin）
- **API 网关**：鉴权、限流、日志；统一错误码；反向代理静态资源。
- **任务队列**：Celery/RQ，支持超时、重试、幂等，写入 Task 表；完成后触发 Webhook/WS。
- **数据存储**：PostgreSQL/MySQL；对象存储 OSS/TOS 保存图片/音频/视频；可选 CDN 加速。

### 模型节点（FastAPI）
- **LLM（Qwen2.5-0.5B/Ollama）**：分镜 JSON 与旁白生成。
- **T2I（SD Turbo）**：根据 Prompt 输出关键帧图片。
- **I2V（SVD Img2Vid，可选）**：将图片转短视频片段。
- **TTS（CosyVoice-mini）**：生成旁白音频。
- **FRP**：frpc 将本地端口暴露给云端任务 Worker，保证内网 GPU 可用。

## 3. 数据与 API 设计
- **数据模型**：
  - Project(id, title, style, created_at)
  - Shot(id, project_id, order, prompt, narration, image_url, video_url, status)
  - Task(id, type, payload, status, result_data, err_msg)
- **网关设计**：
  - **入口**：Nginx/Traefik → API 网关（OpenResty/Lua）→ 应用服务。HTTPS 强制、HSTS、限流（滑动窗口）、WAF 规则拦截。
  - **鉴权**：登录获取 JWT/Token，所有业务接口需在 Header `Authorization: Bearer <token>`；网关验证签名与过期时间；支持临时 STS Token 访问 OSS 资源。
  - **路由与重试**：API 网关转发到 DRF/Gin，5xx 触发幂等接口一次性重试；静态与媒体资源走 OSS/CDN；WebSocket 升级透传。
  - **观测与日志**：接入 TraceID，统一 Access Log（含 upstream）和 Error Log；暴露 Prometheus 指标（qps/rt/4xx/5xx）。
- **API 核心路由与报文**：
  - POST `/api/projects/create`
    - Request: `{ "title": "My Story", "style": "movie", "story": "...500 字以内" }`
    - Response: `{ "project_id": "p_123", "shots": [{"id":"s1","order":1,"prompt":"...","narration":"...","status":"PENDING"}] , "task_id": "t_llm_1" }`
  - GET `/api/projects/{id}/storyboard`
    - Response: `{ "project_id": "p_123", "shots": [...], "updated_at": "2024-11-18T10:00:00Z" }`
  - POST `/api/shots/{id}/update_prompt`
    - Request: `{ "prompt": "sunset city", "narration": "voice text" }`
    - Response: `{ "id": "s1", "prompt": "...", "narration": "..." }`
  - POST `/api/shots/{id}/generate_image`
    - Request: `{ "model": "sd_turbo", "seed": 123, "cfg_scale": 5.5, "steps": 6 }`
    - Response: `{ "task_id": "t_img_1", "status": "QUEUED" }`
  - POST `/api/shots/{id}/generate_video`（可选）
    - Request: `{ "model": "svd_img2vid", "fps": 24, "duration": 3 }`
    - Response: `{ "task_id": "t_vid_1", "status": "QUEUED" }`
  - GET `/api/tasks/{task_id}/status`
    - Response: `{ "task_id": "t_img_1", "status": "SUCCESS", "result": {"image_url":"https://.../s1.png"}, "err_msg": null }`
  - POST `/api/webhook/task_complete`
    - Request: `{ "task_id": "t_img_1", "status": "SUCCESS", "result": {...}, "signature": "hmac" }`
    - 校验 HMAC（共享密钥），写回 Task 表并推送 WS；失败返回 4xx，供模型节点重试。
  - **统一错误码**：`code` 字段（0 成功，4xx 客户端错误、5xx 服务错误、9xx 业务错误如算力不足），`message` 描述，`request_id` 便于追踪。

## 4. 关键流程示意
1) **分镜生成**：客户端提交故事 → 网关写入 Project+Shot → 任务入队调用 LLM → 写回分镜 JSON → WS 推送前端刷新。
2) **图片生成**：客户端调用 generate_image → 任务入队 → Worker 通过 FRP 调用 SD Turbo → 上传 OSS → 回调任务 SUCCESS → WS/轮询更新 URL。
3) **视频合成与导出**：客户端请求合成 → 任务队列调 FFmpeg 拼接（可叠加旁白）→ 成功后提供下载/本地保存路径。

## 5. 视频合成与媒体流水线设计
- **合成输入**：有序 Shot 列表（含 image_url/video_url、旁白音频、过渡配置），全局参数（分辨率、帧率、BGM 选择、字幕开关）。
- **流水线**：
  1. **下载阶段**：从 OSS 并发拉取图片/视频/音频到临时目录，校验哈希；失败重试 3 次。
  2. **转码阶段**：统一分辨率/帧率，图片转视频片段（Ken Burns 或静态帧），旁白转 WAV；BGM 按 LoudNorm 归一。
  3. **拼接阶段**：FFmpeg concat 脚本生成主视频流；插入可选淡入/淡出、交叉淡化；字幕由 SRT/ASS 叠加。
  4. **混音阶段**：旁白与 BGM 混音，控制 Ducking（旁白时降低 BGM 6dB）；输出 AAC。
  5. **导出阶段**：H.264 + AAC MP4，CBR/2-pass 可选；生成本地文件并上传 OSS（若选择云端导出）。
- **并发与资源**：合成任务 CPU 密集，worker 可按 CPU 核数并行；长任务设置超时（如 5 分钟）与断点续传（分段中间文件）。
- **质量控制**：支持预览模式（低码率、短时长）与正式导出模式；合成日志记录关键参数，失败输出 stderr 供诊断。

## 6. 部署与运维
- **环境**：云端 Ubuntu 22.04，Python 3.10+；Nginx+Gunicorn 部署后端；PostgreSQL + Redis；本地 GPU 节点通过 FRP 联通。
- **可观察性**：Prometheus + Grafana 指标，Sentry 捕获异常，结构化日志输出（TraceID 贯穿任务）。
- **安全**：HTTPS、JWT/Token 鉴权；OSS 资源带签名；任务接口限流；敏感配置使用环境变量/密钥管理。

## 7. 风险与缓解
- **生成耗时波动**：通过任务队列超时+重试、WS+轮询双通道反馈。
- **模型不可用**：备用 Mock 服务/降级提示；支持切换到云端备份算力。
- **大文件传输**：采用分段上传至 OSS，返回 CDN URL，客户端异步加载。

## 8. StoryToVideo-server（Go 版本）实现要点
### 8.1 系统初始化与架构引导
- **启动入口**：`main.go`，典型 Go 分层架构，按依赖顺序初始化。
- **流程顺序**：
  1) `config.InitConfig()` 读取 `config.yaml`，加载 MySQL、Redis、MinIO、Worker 地址。
  2) `models.InitDB()` 同时初始化原生 `sql.DB` 与 `gorm.DB`，并自动执行 `doc/sql/StoryToVideo.sql` 完成表结构初始化。
  3) 中间件：`service.InitQueue()`（Redis 队列）、`service.InitMinIO()`（对象存储）。
  4) 处理器：`processor.StartProcessor(5)` 启动异步任务消费者（并发 5 个 AI 任务）。
  5) 路由：启动 Gin HTTP 服务。

### 8.2 数据库设计与模型
- **层级结构**：Project（项目）→ Shot（分镜）→ Task（任务），参数/结果字段使用 JSON 扩展。
- **表要点**：
  - Project：`status` 标记整体进度，`shot_count` 预置镜头数。
  - Shot：与 Project 一对多，`order` 保序，`image_path/audio_path` 存 MinIO 路径。
  - Task：`parameters`/`result` JSON，状态涵盖 `pending/blocked/processing/finished`，支持依赖（`DependsOn`）。
- **混合操作模式**：`models/db.go` 同时使用原生 SQL（如 `GetProjectByID`）和 GORM（如 `BatchCreateShots`）。

### 8.3 路由与业务编排
- **路由版本**：`routers/router.go` 下 RESTful `/v1/api`。
- **CreateProject**（`routers/api/project.go`）：
  1) 创建 Project；
  2) 创建主任务 `TaskTypeStoryboard` 入队；
  3) 预创建 `ShotCount` 个 `TaskTypeShotImage`，初始状态 `blocked`，`DependsOn` 主任务，等待脚本生成后解锁。
- **UpdateShot**（`routers/api/shot.go`）：取消正在处理的旧任务（含远程 Worker 取消 + DB 状态更新），再创建并入队新的 `TaskTypeShotImage`。
- **TaskProgressWebSocket**（`routers/api/task.go`）：每秒轮询数据库状态，比较变更后推送；避免维护分布式 WS 订阅。

### 8.4 异步任务处理（`service/processor.go`）
- **生命周期**：从 Redis 取任务 → 标记 DB `processing` → 调用 `dispatchWorkerRequest` 发送到 Python Worker。
- **轮询机制**：获得 `job_id` 后每 3 秒轮询 `/v1/jobs/:id`；使用 `context.WithCancel` + `pollCancelRegistry` 支持外部取消。
- **结果处理**：
  - Storyboard：解析 JSON，批量写入 Shots。
  - Image/Video/TTS：下载 Worker 返回的资源并通过 `processResourceToMinIO` 流式上传 MinIO，更新 Shot 的资源路径。

### 8.5 对象存储
- **封装**：`service/oss.go` 负责 MinIO，自动创建 Bucket。
- **返回值**：上传后生成长效预签名 URL，前端可直链访问私有资源。

### 8.6 设计总结
- **高可用**：Asynq 队列削峰，后台并发消费。
- **资源敏感**：任务取消贯穿数据库状态、远程 Worker 与本地轮询。
- **扩展性**：Task JSON 参数便于增加新 AI 任务类型，无需改表结构。
- **数据闭环**：任务发起→Worker→MinIO→DB 更新全链路自动化。
